# Presentation: Lab 5 - Sorting Algorithms

## Title Slide
**Lab 5: Implementing Sorting Algorithms**
*LeetCode-Style Problems*

## Introduction
- Overview of sorting algorithms
- Importance in computer science and interviews
- Objective: Implement 5 different sorting algorithms

## Algorithms Overview
- **Bubble Sort**: Simple but inefficient O(n²)
- **Selection Sort**: O(n²) with fewer swaps
- **Merge Sort**: Efficient O(n log n), stable
- **Heap Sort**: O(n log n), in-place
- **Quick Sort**: Fast average O(n log n), worst case O(n²)

## Implementation Details
- All algorithms implemented in C++
- In-place sorting where possible
- Consistent interface: `void sortName(std::vector<int>& arr)`

## Code Structure
- `sorting.h`: Function declarations
- `sorting.cpp`: Implementations
- `sorting_complete.cpp`: All-in-one file
- `main.cpp`: Demonstration program
- Unit tests with Google Test

## Demonstration
- Run main program showing each sort on sample data
- Show time complexities in practice (for larger arrays)

## Testing
- Unit tests for correctness
- Edge cases: empty arrays, single elements
- Verification of sorted output

## Time Complexity Analysis
- Theoretical bounds
- Practical performance comparison
- When to use each algorithm

## Space Complexity
- In-place vs. out-of-place algorithms
- Recursion stack considerations

## Conclusion
- Learned implementation of fundamental algorithms
- Understood trade-offs between different approaches
- Prepared for coding interviews and LeetCode problems

## Q&A
- Open for questions